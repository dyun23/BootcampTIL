## 서버 부하 분산
1. 세션을 DB에 저장  
부하 분산 했을 때 세션 불일치 문제 해결  
DB에 부하에 부하가 많이 감  
2. **세션 클러스터링 :** WAS에 세션을 전부 복사   
부하 분산 했을 때 세션 불일치 문제를 해결  
서버의 메모리 낭비  
3. **스티키 세션 :** 클라이언트가 갔던 곳에만 다시 갈 수 있게 부하 분산   
부하 분산 했을 때 세션 불일치 문제를 해결  
부하 분산이 원하는 대로 되지 않을 수 있음  
  
+) HTTP 프로토콜 구조  
요청 메소드  
URL, URI  
응답 상태 코드  
  
대용량 트래픽 → 부하 분산 → 서버 컴퓨터가 여러 대  
                        → 멀티 스레드 → 스레드가 여러 개일 때  

## 열거형
이름이 있는 상수의 집합을 정의  
주로 대문자로 정의함  

*ex)*
```java
public enum Week { // 각 요일에 해당하는 숫자를 매개변수로 받는 생성자를 정의
    MON(1),
    TUE(2),
    WED(3),
    THU(4),
    FRI(5),
    SAT(6),
    SUN(7);

    int num;
    Week(int num) {
        this.num = num;
    }
}
```

## 리플렉션
실행 중인 객체에 class 파일을 통해 직접 접근하는 방법 (변수, 메소드, 상위 클래스 등)  
접근 제어자랑 상관 없이 가능  
접근제어자 없이 접근하기 때문에 캡슐화 X  
속도가 느림  
ex) `클래스이름.class.get메소드();`  

## 컬렉션
프로그래밍에서 많이 사용되는 자료 구조를 자바에서 미리 구현해둔 것  
*ex) 스택, 큐, 리스트, 트리, 해시 등*  
인터페이스와 다형성을 이용해서 구현했기 때문에 각 컬렉션들의 메소드가 대부분 비슷  
다형성 : 상위클래스명 [변수명] = new 하위클래스명();  
  

### 컬렉션 인터페이스의 메소드
`add()` : 데이터 추가  
`remove()` : 데이터 삭제  
`size()` : 저장된 데이터의 수  
`contains()` : 데이터가 있는지 확인  
`isEmpty()`  : 데이터가 없는지 확인  
`iterator()` : 컬렉션의 반복자를 반환, 일반적으로 반복문과 함께 사용  
`toArray()` : 모든 데이터를 배열로 반환  

## ArrayList
내부적으로 배열을 사용해서 데이터를 저장  
처음엔 데이터의 크기가 정해져 있고 데이터를 저장하면서 추가 공간이 필요하면 데이터 공간을 늘릴 수 있음  
실제 저장된 데이터의 크기 `.size()`  
실제 내부적인 데이터 저장 공간의 크기는   
`*getCapatacity*(리스트명)` default 10  

**특징**  
- 조회가 빠름  
- 데이터의 저장 순서 유지  
- 중복 가능  
- 삽입, 삭제가 느림 (단, 순차적으로 삽입, 삭제는 빠름)  
- 스레드 세이프하지 않음  

## List와 Map 비교
### **LIST**
List는 Memory 안의 특정한 동일 공간에 뭉텅이로 저장  
알맞은 데이터 저장 공간만 있다면 데이터 저장 속도는 빠름  
또한, 순차적으로 데이터를 저장하므로, 데이터 특징이 포지션 별로 의미가 있을 때 사용하는 것이 좋습니다.

### **MAP** 
Map을 이용해 저장할 때는 List처럼 뭉텅이로 저장하는 것이 아닌, Map에 저장할 때마다, 빈 공간을 찾아 저장  
List보다는 데이터 저장 속도가 느릴 수 있음  

## HashMap
key : value 한쌍으로 데이터 저장하는 구조  
중복 X, 순서 X  
삽입, 삭제, 조회 모두 빠름  
동기화 안됨  

## 제네릭
타입을 클래스 내부에서 결정하는 것이 아니라 밖에서 결정  
```java
public class Test<T, E> {
   public T value;
   public E value2;
}

Test<String, Integer> test01 = new Test<String, Integer>(); // 생성 시 타입 지정
```

## SET
순서와 중복이 없는 리스트

## Stack
LIFO 구조  
마지막에 넣은 데이터가 제일 먼저 나오는 구조  
메모리 구조 중 하나가 Stack 구조로 동작 *(메소드 호출, 함수 호출)*  

## Queue
FIFO 구조  
처음 넣은 데이터가 제일 먼저 나오는 구조  
작업 목록  

## ProirityQueue
저장되는 데이터에 **우선순위**를 부여해서 우선 순위가 높거나 낮은 순으로 정렬해서 저장하는 구조

## LinkedList
리스트랑 큐를 모두 상속 받아와서 두 가지 기능 모두 사용 가능  
데이터의 중간에 삽입, 삭제가 빠름  

## Vector(ArrayList 이전버전), HashTabel(HashMap 이전 버전)
메소드들에 `synchronized`가 달려있어 기본적으로 멀티 스레드 환경에서 동기화 제공  